/*******************************************************************************
 * Copyright (c) 2010 Appscio Dual License. All rights reserved. This program and the accompanying materials are made available under your choice of the GNU Lesser Public License v2.1 or the Apache License, Version 2.0. See the included License-dual file.
 ******************************************************************************/
package com.appscio.mpf.junit;
import java.io.File;
import java.io.FileInputStream;
import java.io.FileOutputStream;
import java.io.FileReader;
import java.io.IOException;
import java.io.InputStream;
import java.io.OutputStream;
import java.util.ArrayList;
import java.util.Arrays;
import java.util.Collections;
import java.util.Comparator;
import java.util.HashMap;
import java.util.HashSet;
import java.util.Iterator;
import java.util.List;
import java.util.Map;
import java.util.Properties;
import java.util.Set;

import junit.framework.AssertionFailedError;
import junit.framework.Test;
import junit.framework.TestCase;
import junit.framework.TestResult;
import junit.framework.TestSuite;

/**
 * Test suite that discovers and exercises MPF plugins.
 * <p>
 * Supports selection of tests based on a system property named "select".  select expressions are of the
 * form res=val, where res is a resource name generated by scanning test.properties, and stripping off
 * the test name, then using the test-name to enable or disable tests.  val is a value to match.
 * <p>
 * For example, -Dselect="resource.output=test.mpg" would match tests that are declared as
 * test-N.resource.output=test.mpg in the  test.properties file, i.e. match all
 * tests that generate an output file named test.mpg.
 * <p>The res=val format is completely general (with some special cases governing exit status
 * and timeout), and can be used to specify general assertions about tests.
 * <p>This -Dselect property can take the following values:
 * <ol>
 *    <li>Simple string expression governed by the select.g expression.  <br/>E.g. resource.output=test.mpg</li>
 *    <li>File containing select.g expression.  <br/>E.g. @test.sel</li>
 *    <li>Complement of file containing select.g expression, <br/>E.g. @!test.sel.  This allows the negation
 *       of the expression inside test.sel to be used as the select expression.</li>
 *  </ol>
 * A typical test.properties file is shown below: note the use of assertions such as status.ok and
 * timeout.ok: these are given special treatment by the test engine.
 * <pre>
 *   # OK for test-1 to fail with kill status (due to timeout).
 *   test-1.status.ok=143
 *   # OK for test-1 to fail with timeout.
 *   test-1.timeout.ok=true
 *   # USC algorithm will timeout.
 *   test-2-cot-usc.timeout.ok=true
 *   # Required/Generated resources.
 *   test-1.resource.output=events.rdf
 *   test-1.resource.output=tracks.rdf
 *   test-1-mock.resource.output=events.rdf
 *   test-2-mock.resource.output=events.rdf
 *   test-2-mock.resource.output=events.rdf
 *
 *   test-1-cot-mock.requires=grails.test-post
 *   test-2-cot-usc.requires=grails.test-post
 * </pre>
 * Special predicates to the JVM running PluginSuite:
 * <p>
 * <ul>
 * <li>test.env={list} -- Semi-colon separated list of environment variables to pass to the test shell
 *     <p>NAME=VALUE implies set the environment variable "NAME" to "VALUE".  Simple strings only.
 *     <p>@@ implies pass the parent process environment (environment is otherwise empty)
 *     <p>@file implies pass environment variables from a file (VARIABLE=VALUE).  Simple strings only.
 * </li>
 * <li>test.dirs={list} -- Semi-colon separated list of directories to process (relative to working dir).
 * <li>timeout.ok=false|true --  Deny/Allow timeout of the test.  Default timeout is 10 seconds.</li>
 * <li>timeout={seconds} -- Specify timeout for test.</li>
 * <li>test.enabled={paths} -- Specify paths for valid test (glob string match, e.g. dir/test-1|test-2.*)</li>
 * <li>test.disabled={paths} -- Specify paths for valid test (glob string match, e.g. dir/test-1|test-2.*)</li>
 * </ul>
 */
public class PluginSuite {

    protected static boolean quiet = true;
    protected SelectEvaluator evaluator;
    protected static Analyzer analyzer = null;
    protected String enabled = System.getProperty("test.enabled");
    protected String disabled = System.getProperty("test.disabled");
    float scale = Float.valueOf(System.getProperty("timeout.scale", "1.0"));

    {
    	// Convert glob to regex.
    	if (enabled != null && enabled.length() > 0) {
    		enabled = enabled.replaceAll("/", "\\/").replaceAll("\\.","\\\\.").replaceAll("\\*", ".\\*");
    		enabled = ".*(" + enabled + ").*";
    	}
    	if (disabled != null && disabled.length() > 0) {
    		disabled = disabled.replaceAll("/", "\\/").replaceAll("\\.","\\\\.").replaceAll("\\*", ".\\*");
    		disabled = ".*(" + disabled + ").*";
    	}
    }

    public void init() throws Exception {
        String select = System.getProperty("select", null);
        if (select != null) {
            evaluator = new SelectEvaluator();
            if (select.startsWith("@")) {
                select = select.substring(1);
                boolean not = false;
                if (select.startsWith("!")) {
                    // Invert the expression.
                    not = true;
                    select = select.substring(1);
                }
                // Read from a file.
                File file = new File(select);
                select = evaluator.rdp.load(new FileReader(file));
                if (not)
                    select = "!(" + select + ")";
            }
            evaluator.parse(select);
        }
        // How to analyze results. This property should be a class (if specified without
        // package it will be looked for in com.appscio.mpf.junit, then in the default package).
        String analyze = System.getProperty("analyze", "");
        Class analyzecls = null;
        if (!analyze.equals("")) {
            if (analyze.contains(".")) {
                analyzecls = Class.forName(analyze);
            } else {
                try {
                    analyzecls = Class.forName("com.appscio.mpf.junit." + analyze);
                } catch (ClassNotFoundException x) {
                    try {
                        analyzecls = Class.forName(analyze);
                    } catch (ClassNotFoundException x2) {
                        // Ignore.
                    }
                }
            }
        }
        if (analyzecls != null) {
            analyzer = (Analyzer) analyzecls.newInstance();
        }
    }



    /**
     * Pseudo JUnit testcase to run a test script in its own directory and record results.
     * @author stuffs
     *
     */
    public class PluginTest extends TestCase {
        protected File file;
        public PluginTest() {}
        public PluginTest(File file) {
            // Synthesize a suitable test-method name.
            setName(file.getPath().replace("/", ".").replaceAll("^\\.\\.", ""));
            this.file = file;
        }
        public void test() {
            // Fake to let suite add test.
        }
        @Override
        public void run(TestResult result) {
        	if (file.getName().endsWith(".disabled")) {
        		result.startTest(this);
        		result.endTest(this);
        		return;
        	}
            StringBuffer out = new StringBuffer(), err = new StringBuffer();
            try {
                File dir = file.getParentFile();
                String name = file.getName();
                // Allow test invocation to be done with a prefix to control shell variables.
                // E.g. -Dprefix="prefix=valgrind --leak-check=full version=-0.10" will run tests
                // with gst-launch-0.10 using valgrind.
                String prefix = System.getProperty("test.prefix", "''");
                String args = System.getProperty("test.args", "''");
                String version = System.getProperty("test.version", "''");
                String gstargs = System.getProperty("test.gstargs", "''");
                String command = "./test.sh " + dir + " " + name + " " + prefix + " " + version + " " + args + " " + gstargs;


                // Get any test properties from the file.
                Properties testprops = loadProperties(new File(dir, "test.properties"), "MPF");

                // !quiet enables dump of subprocess output/error to system.out
                quiet = Boolean.valueOf(getProperty(testprops, name, "quiet", System.getProperty("quiet", "true")));
                int wait = Integer.valueOf(getProperty(testprops, name, "timeout", System.getProperty("timeout", "20")));
                wait *= scale;

                boolean fake = Boolean.valueOf(System.getProperty("fake", "false"));
                if (fake) {
                    System.out.println("faked: " + command + " because fake=true set in system properties (check test.properties)");
                    result.startTest(this);
                    result.endTest(this);
                    return;
                }

                String toks[] = System.getProperty("test.env", "@@").split(";");
                List<String> envp = new ArrayList<String>();
                for (int i=0; i<toks.length; i++) {
                	if (toks[i].startsWith("@")) {
                		// Propagate parent environment to child..
                		if (toks[i].startsWith("@@")) {
                			if (toks[i].equals("@@")) {
                				// All parent variables.
	                			Map<String, String> parent = System.getenv();
	                			for (String k: parent.keySet()) {
	    	                		envp.add(k + "=" + parent.get(k));
	                			}
                			} else {
                				// Named parent variable.
                				String t = toks[i].substring(2);
	                			Map<String, String> parent = System.getenv();
	                			for (String k: parent.keySet()) {
	                				if (k.matches(t)) {
	                					envp.add(k + "=" + parent.get(k));
	                				}
	                			}
                			}
	                	} else {
		                	// Read properties file.
		                	File fenv = new File(toks[i].substring(1));
		                	Properties env = new Properties();
		                	env.load(new FileReader(fenv));
		                	for (Object k: env.keySet()) {
		                		envp.add(k + "=" + env.getProperty(k.toString()));
		                	}
	                	}
                	} else {
                		envp.add(toks[i]);
                	}
                }

                result.startTest(this);
                // Run test process.
                System.out.println("testing:  " + command);
                final Process p = Runtime.getRuntime().exec(command, envp.toArray(new String[0]));
                String path = file.getPath().replaceAll("\\.\\./", "");
                File results = new File("junit_results/" + path + ".out");
                File errors = new File("junit_results/" + path + ".err");
                // results.delete();
                // errors.delete();
                results.getParentFile().mkdirs();
                FileOutputStream fos = new FileOutputStream(results);
                FileOutputStream fes = new FileOutputStream(errors);
                fos.write((results.getPath()+"\n\n").getBytes());
                fes.write((errors.getPath()+"\n\n").getBytes());
                Thread dout = dump(p.getInputStream(), fos, out);
                Thread derr = dump(p.getErrorStream(), fes, err);

                // Set up to time the process out.
                Timeout timeout = new Timeout();
                timeout.killafter(p, wait);
                int status = p.waitFor();
                if (!timeout.timedout) {
                    // Wait for output/error gathers to be done.
                    dout.join();
                    derr.join();
                }
                timeout.cancel();

                fos.flush();
                fes.flush();
                fos.close();
                fes.close();

                // Analysis?
                if (analyzer != null) {
                    analyzer.analyze("junit_results/" + file.getPath(), results, errors);
                }

                // Report failures.
                boolean timeoutok = Boolean.valueOf(getProperty(testprops, name, "timeout.ok", "false"));
                if (timeout.timedout) {
                    if (!timeoutok) {
                        result.addFailure(this, new AssertionFailedError("test " + getName() + " timed out after " + wait + " seconds\nstderr:\n" + err));
                    } else {
                        System.out.println("info: test " + getName() + " timed out after " + wait + " seconds (marked timeout.ok in test.properties)\nstderr:\n" + err + "stdout:\n" + out);
                    }
                } else {
                    // Filter out based on status.ok settings for test.
                    Set<String> ok = new HashSet<String>();
                    ok.addAll(Arrays.asList(getProperty(testprops, name,  "status.ok","").split(";")));
                    if (status != 0) {
                        boolean all = Boolean.valueOf(System.getProperty("all.errors", "false"));
                        if (all || !ok.contains("" + status)) {
                            result.addFailure(this, new AssertionFailedError("test " + getName() + " process returned " + status + "\nstderr:\n" + err));
                        } else {
                            System.out.println("warning: failure " + status + " ignored for " + command + " (check test.properties)");
                        }
                    }
                }
                result.endTest(this);
            } catch (Throwable t) {
                result.addFailure(this, new AssertionFailedError(t +  "\nstderr:\n" + err + "stdout:\n" + out));
                result.endTest(this);
            }
        }
    }

    /**
     * Kill a process after a given timout (seconds).
     * @param p Process to kill.
     * @param timeout Timeout in seconds.
     */
    public class Timeout {
        protected boolean timedout;
        Thread timer;
        public void killafter(final Process p, final int timeout) {
            (timer = new Thread() {
                public void run() {
                    try {
                        Thread.sleep(timeout*1000);
                        timedout = true;
                        p.destroy();
                    } catch (InterruptedException x) {
                    }
                }
            }).start();
        }
        public void cancel() {
            timer.interrupt();
        }
    }

    public static Thread dump(final InputStream s, final OutputStream o, final StringBuffer buf) {
        Thread t = new Thread() {
            public void run() {
                try {
                    while(true) {
                        int c = s.read();
                        if (c == -1)
                            break;
                        if (buf != null) buf.append((char)c);
                        if (o != null) o.write(c);
                        if (!quiet)
                            System.out.print((char)c);
                    }
                } catch (Exception x) {
                }
            }
        };
        t.setPriority(Thread.MAX_PRIORITY);
        t.start();
        return t;
    }

    public static Test suite() throws Exception {
        TestSuite suite = new TestSuite("Test for default package");
        //$JUnit-BEGIN$
        PluginSuite ps = new PluginSuite();
        ps.init();
        String testdirs = System.getProperty("test.dirs", null);
        if (testdirs != null) {
        	String dirs[] = testdirs.split(";");
        	for (String dir: dirs) {
        		System.out.println("adding " + dir + " to suite");
        		ps.findTests(new File(dir), suite);
        	}
        } else {
        	String MPF = System.getProperty("MPF", ".");
        	// Default MPF set of tests.
	        ps.findTests(new File(MPF + "/tests"), suite);
	        ps.findTests(new File(MPF + "/components"), suite);
        }
        if (analyzer != null) {
            suite.addTest(new TestCase() {
                {
                    setName(analyzer.getClass().getName());
                }
                @Override
                public void run(TestResult result) {
                    try {
                        result.startTest(this);
                        analyzer.generateReport(new File("junit_results/html"));
                        result.endTest(this);
                    } catch (Throwable t) {
                        result.addError(this, t);
                        result.endTest(this);
                    }
                }
                @Override
                public int countTestCases() {
                    // TODO Auto-generated method stub
                    return 1;
                }
            });
        }
        //$JUnit-END$
        return suite;
    }


    public List<File> findTests(File dir, TestSuite suite) {
        return findTests(dir, suite, null);
    }

    /**
     * Find all candidate tests in a subdirectory and add them to test-suites, recursively.  Sorted
     * by name pattern test-<n>[-extra]
     * @param dir The directory to search
     * @param suite The suite to add the suites/test cases into.
     * @return List of test-files found.
     */
    public List<File> findTests(File dir, TestSuite suite,  String name) {
        File files[] = dir.listFiles();
        List<File> list = new ArrayList<File>();
        List<File> tests = new ArrayList<File>();
        if (files == null)
            return list;
        for (File file: files) {
            if (file.getName().startsWith("."))
                continue;
            if (file.isDirectory()) {
                TestSuite s = new TestSuite(name != null? name: file.getName());
                list.addAll(findTests(file, s, null));
                if (s.countTestCases() > 0)
                    suite.addTest(s);
            }
            if (file.getName().startsWith("test-") && file.canExecute() && !file.getName().contains(".") && file.getParentFile().getName().equals("tests")) {
            	if (isEnabled(file)) {
                    tests.add(file);
                } else {
                	// tests.add(new File(file + ".disabled"));
                }
            }
        }
        // Sort filenames based on test-n[-extra] pattern.  Sort by n, ascending, and by -extra if present.
        Collections.sort(tests, new Comparator<File>() {
            @Override
            public int compare(File f1, File f2) {
                String n1 = f1.getName();
                String n2 = f2.getName();
                String s1[] = n1.split("-");
                String s2[] = n2.split("-");
                try {
                    if (s1.length == s2.length) {
                        if (s1.length >= 2 && s2.length >= 2) {
                            return Integer.valueOf(s1[1]).compareTo(Integer.valueOf(s2[1]));
                        } else {
                            return f1.getName().compareTo(f2.getName());
                        }
                    }
                } catch (Exception x) {
                }
                return n1.length() - n2.length();
            }
        });
        for (File test: tests) {
            suite.addTest(new PluginTest(test));
        }
        return list;
    }


    // Run up the tree looking for test.properties files, then apply them from the top down.
    // For a given test named test-1 , valid properties include:
    // <ul>
    //   <li>test-1.status.ok=123[;456] -- List of OK status.  E.g. 143 is process kill, due to timeout.</li>
    //   <li>test-1.timeout=10 -- Apply timeout of 10 seconds. </li>
    //   <li>test-1.timeout.ok=true -- Test is expected to timeout </li>
    // </ul>
    public Properties loadProperties(File file, String stop) {
        Properties props = new Properties();
        try {
            List<File> files = new ArrayList<File>();
            File dir = file.getParentFile();
            do {
                File f = new File(dir, "test.properties");
                if (f.getName().equals(stop))
                    break;
                // Push into list.
                if (f.exists())
                    files.add(0, f);
                dir = dir.getParentFile();
            } while (dir != null);
            // Pop to process.
            for (File f: files) {
                FileInputStream ps = new FileInputStream(f);
                props.load(ps);
                ps.close();
            }
        } catch (IOException iox) {
            iox.printStackTrace();
        }
        return props;
    }

    public Properties filter(Properties testprops, String name) {
        Properties props = new Properties();
        Iterator<?> iter = testprops.keySet().iterator();
        while (iter.hasNext()) {
            String key = (String)iter.next();
            if (key.startsWith(name + ".")) {
                props.put(key.substring(name.length()+1), testprops.get(key));
            }
        }
        return props;
    }

    /**
     * Determines whether a test is enabled based on a simple additive combination of -Dresource.X=Y
     * specifications in the System properties, as discovered in the test.properties files associated
     * with the test.
     *
     * @param file
     * @return
     */
    public boolean isEnabled(File file) {

        // Look for test.enabled to run a subset of tests.
    	if (enabled != null && enabled.length() > 0) {
            if (!file.getPath().matches(enabled)) {
                System.out.println("skipped: " + file + " because it did not contain " + enabled + " specified in system property test.enabled");
                return false;
            }
        }

    	if (disabled != null && disabled.length() > 0) {
        	if (file.getPath().matches(disabled)) {
                System.out.println("skipped: " + file + " because it is disabled because " + disabled + " specified in system property test.disabled");
                return false;
        	}
        }

        // Any resource filters?  If not, enable all.
        File dir = file.getParentFile();
        Properties testprops = loadProperties(new File(dir, "test.properties"), "MPF");
        String name = file.getName();

        int time = Integer.valueOf(getProperty(testprops, name, "timeout", System.getProperty("timeout","20")));
        time *= scale;
        int timeout = Integer.valueOf(System.getProperty("timeout", "20"));
        // Don't run slow tests if max-timout is set.
        if (timeout == 0 || time > timeout) {
            System.out.println("skipped:  " + file + " because scaled (" + scale + ") test.properties timeout " + time + " > " + timeout + " (System Property timeout)");
            return false;
        }

        // Any selection criteria?
        if (evaluator == null)
            return true;

        Properties props = filter(testprops, name);
        Iterator<?> iter = props.keySet().iterator();
        Map<String, String> vmap = new HashMap<String, String>();
        while (iter.hasNext()) {
            String key = (String)iter.next();
            String value = props.getProperty(key);
            vmap.put(key, value);
        }
        boolean ok = evaluator.evaluate(vmap);
        if (ok) {
            System.out.println("selected: "+ file + " because " + evaluator.rdp.expression() + " in test.properties");
        }
        // No match.
        // System.out.println("skipped: " + file + " because " + props + " did not match System properties (check test.properties)");
        return ok;
    }

    public String getProperty(Properties testprops, String name, String key, String def) {
        return testprops.getProperty(name + "." + key,
                testprops.getProperty(key, def));
    }
}
